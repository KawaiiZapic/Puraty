diff --git a/dist/index.d.ts b/dist/index.d.ts
index 8ddb0347458ea1eff1ac6e37dc7f4bedbd0dd29f..94feea1c33638c310af9b35aecae68414529e756 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -9,8 +9,12 @@ export interface TsxConfig {
 type IfTsxConfig<T extends string, TIF, TELSE> = TsxConfig[T] extends false ? TELSE : TIF;
 type IntrinsicElementsCombined = IfTsxConfig<"html", IntrinsicElementsHTML, unknown> & IfTsxConfig<"svg", IntrinsicElementsSVG, unknown>;
 declare global {
+    interface Ref<T> {
+        value: T;
+        onUpdate: (fn: () => void) => void;
+    }
     namespace JSX {
-        type Element = IfTsxConfig<"html", HTMLElement, never> | IfTsxConfig<"svg", SVGElement, never>;
+        type Element = IfTsxConfig<"html", HTMLElement, never> | IfTsxConfig<"svg", SVGElement, never> | Node;
         interface ElementAttributesProperty {
             props: unknown;
         }
diff --git a/dist/jsx-runtime.js b/dist/jsx-runtime.js
index 9ace7f924b6a0782cf3fa2fc7aa88c3549167333..9b32afc2d9139e7f105519aa765c66c508460ea6 100644
--- a/dist/jsx-runtime.js
+++ b/dist/jsx-runtime.js
@@ -8,6 +8,17 @@ const utils_1 = require("./utils");
 function jsx(tag, props) {
     if (typeof tag === "function")
         return tag(props);
+    else if (typeof tag === "undefined") {
+        if (props.children instanceof Node) {
+            return props.children;
+        }
+        else if (typeof props.children === "string" || typeof props.children === "number") {
+            return document.createTextNode(props.children.toString());
+        }
+        else {
+            tag = "div";
+        }
+    }
     const { children, ...attrs } = props;
     const { finalTag, finalAttrs } = (0, utils_1.applyTsxTag)(tag, attrs);
     const element = (0, utils_1.createDomElement)(finalTag, finalAttrs);
diff --git a/dist/setAttributes.js b/dist/setAttributes.js
index 85dcea63462e7fe6208c0ec3b62719c5a5a12e99..d3e035450606434a54ee7c39dbbbf508a4808500 100644
--- a/dist/setAttributes.js
+++ b/dist/setAttributes.js
@@ -11,35 +11,47 @@ function transferKnownProperties(source, target) {
 }
 /** "on" followed by an uppercase character. Not sure if there are any events with anything other than A-Z. Checking unicode just to be safe */
 const eventAttributeName = /^on\p{Lu}/u;
+function setAttribute(element, name, value) {
+    if (typeof value.onUpdate === "function") {
+        value.onUpdate(() => {
+            setAttribute(element, name, value.value);
+        });
+        return void setAttribute(element, name, value.value);
+    }
+    // Ignore some debug props that might be added by bundlers
+    if (name === "__source" || name === "__self" || name === "tsxTag")
+        return;
+    if (name === "class") {
+        const finalValue = (0, tsx_dom_types_1.classnames)(value);
+        if (finalValue)
+            element.setAttribute(name, finalValue);
+    }
+    else if (name === "ref") {
+        value.current = element;
+    }
+    else if (eventAttributeName.test(name)) {
+        const finalName = name.replace(/Capture$/, "");
+        const useCapture = name !== finalName;
+        const eventName = finalName.toLowerCase().substring(2);
+        element.addEventListener(eventName, value, useCapture);
+    }
+    else if (name === "style" && typeof value !== "string") {
+        // Special handler for style with a value of type CSSStyleDeclaration
+        transferKnownProperties(value, element.style);
+    }
+    else if (name === "dangerouslySetInnerHTML")
+        element.innerHTML = value;
+    else if (value === true)
+        element.setAttribute(name, name);
+    else if (value || value === 0 || value === "")
+        element.setAttribute(name, value.toString());
+    else
+        element.removeAttribute(name);
+}
 function setAttributes(element, attrs) {
     for (const name of Object.keys(attrs)) {
-        // Ignore some debug props that might be added by bundlers
-        if (name === "__source" || name === "__self" || name === "tsxTag")
+        if (!(element instanceof HTMLElement || element instanceof SVGElement))
             continue;
-        const value = attrs[name];
-        if (name === "class") {
-            const finalValue = (0, tsx_dom_types_1.classnames)(value);
-            if (finalValue)
-                element.setAttribute(name, finalValue);
-        }
-        else if (name === "ref") {
-            value.current = element;
-        }
-        else if (eventAttributeName.test(name)) {
-            const finalName = name.replace(/Capture$/, "");
-            const useCapture = name !== finalName;
-            const eventName = finalName.toLowerCase().substring(2);
-            element.addEventListener(eventName, value, useCapture);
-        }
-        else if (name === "style" && typeof value !== "string") {
-            // Special handler for style with a value of type CSSStyleDeclaration
-            transferKnownProperties(value, element.style);
-        }
-        else if (name === "dangerouslySetInnerHTML")
-            element.innerHTML = value;
-        else if (value === true)
-            element.setAttribute(name, name);
-        else if (value || value === 0 || value === "")
-            element.setAttribute(name, value.toString());
+        setAttribute(element, name, attrs[name]);
     }
 }
diff --git a/dist/types.d.ts b/dist/types.d.ts
index e6c96a6edb0f50032b6a7dbdfde3b15c01ac9780..5b69dfaadb75f28acd559f3af7efc83bcbf684e8 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -1,5 +1,8 @@
 import type { EventAttributes, StyleAttributes, HTMLAttributes, HTMLElementAttributes, SVGElementAttributes } from "tsx-dom-types";
-export type ComponentChild = ComponentChild[] | JSX.Element | string | number | boolean | undefined | null;
+type RefAttr<T> = {
+    [K in keyof T]?: Ref<Extract<T[K], string | boolean | undefined>> | T[K];
+};
+export type ComponentChild = ComponentChild[] | JSX.Element | string | number | boolean | undefined | null | Ref<JSX.Element | string | number | boolean | undefined | null>;
 export type ComponentChildren = ComponentChild | ComponentChild[];
 export interface BaseProps {
     children?: ComponentChildren;
@@ -22,10 +25,10 @@ export type CustomElementProps<TBase, TName extends keyof HTMLElementTagNameMap
 export type SVGAndHTMLElementKeys = keyof SVGElementTagNameMap & keyof HTMLElementTagNameMap;
 export type SVGOnlyElementKeys = Exclude<keyof SVGElementTagNameMap, SVGAndHTMLElementKeys>;
 export type IntrinsicElementsHTML = {
-    [TKey in keyof HTMLElementTagNameMap]?: HTMLElementAttributes<TKey> & HTMLComponentProps<HTMLElementTagNameMap[TKey]> & EventAttributes<HTMLElementTagNameMap[TKey]>;
+    [TKey in keyof HTMLElementTagNameMap]?: RefAttr<HTMLElementAttributes<TKey>> & HTMLComponentProps<HTMLElementTagNameMap[TKey]> & EventAttributes<HTMLElementTagNameMap[TKey]>;
 };
 export type IntrinsicElementsSVG = {
-    [TKey in SVGOnlyElementKeys]?: SVGElementAttributes<TKey> & HTMLComponentProps<SVGElementTagNameMap[TKey]> & EventAttributes<SVGElementTagNameMap[TKey]>;
+    [TKey in SVGOnlyElementKeys]?: RefAttr<SVGElementAttributes<TKey>> & HTMLComponentProps<SVGElementTagNameMap[TKey]> & EventAttributes<SVGElementTagNameMap[TKey]>;
 };
 export type IntrinsicElementsHTMLAndSVG = IntrinsicElementsHTML & IntrinsicElementsSVG;
 export interface CustomElementsHTML {
@@ -33,3 +36,4 @@ export interface CustomElementsHTML {
 export type RefType<T> = {
     current: T | null;
 };
+export {};
diff --git a/dist/utils.js b/dist/utils.js
index 6502f9e224de06eb8f8525aa5265090c6a186adf..80da17c313c4407d430ac4673c22b1a8ad7ab437 100644
--- a/dist/utils.js
+++ b/dist/utils.js
@@ -4,7 +4,36 @@ exports.applyChildren = applyChildren;
 exports.createDomElement = createDomElement;
 exports.applyTsxTag = applyTsxTag;
 function applyChild(element, child) {
-    if (child instanceof Element)
+    if (child && typeof child === "object" && "onUpdate" in child && typeof child.onUpdate === "function") {
+        let el = null;
+        const handler = () => {
+            const value = child.value;
+            if (value instanceof Node) {
+                el?.parentNode?.removeChild(el);
+                el = value;
+                element.appendChild(el);
+            }
+            else if (typeof value === "string" || typeof value === "number") {
+                if (el instanceof Text) {
+                    el.textContent = value.toString();
+                }
+                else {
+                    el?.parentNode?.removeChild(el);
+                    el = document.createTextNode(value.toString());
+                    element.appendChild(el);
+                }
+            }
+            else {
+                console.warn("Unknown type to append: ", value);
+                el?.parentNode?.removeChild(el);
+                el = null;
+            }
+        };
+        child.onUpdate(handler);
+        handler();
+        return;
+    }
+    if (child instanceof Node)
         element.appendChild(child);
     else if (typeof child === "string" || typeof child === "number")
         element.appendChild(document.createTextNode(child.toString()));
diff --git a/package.json b/package.json
index 2b7b2386ffde6f3a12ebc2cae1a362ecb5b35a61..a01a1f0ce4aba1a6559c0693b43f4e2260d5f18f 100644
--- a/package.json
+++ b/package.json
@@ -35,7 +35,11 @@
     "build": "rimraf dist && tsc -p tsconfig.build.json",
     "test": "jest"
   },
+  "devDependencies": {
+    "rimraf": "^6.0.1"
+  },
   "dependencies": {
+    "@lusito/tsconfig": "^1.0.5",
     "tsx-dom-types": "2.1.0"
   }
 }
diff --git a/src/index.ts b/src/index.ts
index b93cf5cf44499542518c229412de891fd60b92a5..ccf1d359a87a8767a2ec62e9399c1e1fdbe13dde 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -16,10 +16,14 @@ type IntrinsicElementsCombined = IfTsxConfig<"html", IntrinsicElementsHTML, unkn
     IfTsxConfig<"svg", IntrinsicElementsSVG, unknown>;
 
 declare global {
+    interface Ref<T> {
+        value: T;
+        onUpdate: (fn: () => void) => void
+    }
     // eslint-disable-next-line @typescript-eslint/no-namespace
     namespace JSX {
         // Return type of jsx syntax
-        type Element = IfTsxConfig<"html", HTMLElement, never> | IfTsxConfig<"svg", SVGElement, never>;
+        type Element = IfTsxConfig<"html", HTMLElement, never> | IfTsxConfig<"svg", SVGElement, never> | Node;
 
         // The property name to use
         interface ElementAttributesProperty {
diff --git a/src/jsx-runtime.ts b/src/jsx-runtime.ts
index f34a346035987e7892b41c0ee3e30789c8406275..f57a2f91664efe8a787b3d42ebabbc0842a64338 100644
--- a/src/jsx-runtime.ts
+++ b/src/jsx-runtime.ts
@@ -4,6 +4,15 @@ import { applyChildren, createDomElement, applyTsxTag } from "./utils";
 
 export function jsx(tag: string | FC, props: BaseProps): JSX.Element {
     if (typeof tag === "function") return tag(props);
+    else if (typeof tag === "undefined") {
+        if (props.children instanceof Node) {
+            return props.children;
+        } else if (typeof props.children === "string" || typeof props.children === "number") {
+            return document.createTextNode(props.children.toString());
+        } else {
+            tag = "div";
+        }
+    }
 
     const { children, ...attrs } = props;
     const { finalTag, finalAttrs } = applyTsxTag(tag, attrs);
diff --git a/src/setAttributes.ts b/src/setAttributes.ts
index 32fb57405a51fcdf533b48b6e2ac33acf720e2d6..c752b56191eafcd62c10af547011165d7af9fb45 100644
--- a/src/setAttributes.ts
+++ b/src/setAttributes.ts
@@ -12,27 +12,37 @@ function transferKnownProperties(source: any, target: any) {
 /** "on" followed by an uppercase character. Not sure if there are any events with anything other than A-Z. Checking unicode just to be safe */
 const eventAttributeName = /^on\p{Lu}/u;
 
+function setAttribute(element: HTMLElement | SVGElement, name: string, value: any) {
+    if (typeof value.onUpdate === "function") {
+        value.onUpdate(() => {
+            setAttribute(element, name, value.value);
+        });
+        return void setAttribute(element, name, value.value);
+    }
+    // Ignore some debug props that might be added by bundlers
+    if (name === "__source" || name === "__self" || name === "tsxTag") return;
+    if (name === "class") {
+        const finalValue = classnames(value as ClassType);
+        if (finalValue) element.setAttribute(name, finalValue);
+    } else if (name === "ref") {
+        (value as RefType<any>).current = element;
+    } else if (eventAttributeName.test(name)) {
+        const finalName = name.replace(/Capture$/, "");
+        const useCapture = name !== finalName;
+        const eventName = finalName.toLowerCase().substring(2);
+        element.addEventListener(eventName, value as EventListenerOrEventListenerObject, useCapture);
+    } else if (name === "style" && typeof value !== "string") {
+        // Special handler for style with a value of type CSSStyleDeclaration
+        transferKnownProperties(value, element.style);
+    } else if (name === "dangerouslySetInnerHTML") element.innerHTML = value as string;
+    else if (value === true) element.setAttribute(name, name);
+    else if (value || value === 0 || value === "") element.setAttribute(name, value.toString());
+    else element.removeAttribute(name);
+}
+
 export function setAttributes(element: JSX.Element, attrs: ComponentAttributes) {
     for (const name of Object.keys(attrs)) {
-        // Ignore some debug props that might be added by bundlers
-        if (name === "__source" || name === "__self" || name === "tsxTag") continue;
-
-        const value = attrs[name];
-        if (name === "class") {
-            const finalValue = classnames(value as ClassType);
-            if (finalValue) element.setAttribute(name, finalValue);
-        } else if (name === "ref") {
-            (value as RefType<any>).current = element;
-        } else if (eventAttributeName.test(name)) {
-            const finalName = name.replace(/Capture$/, "");
-            const useCapture = name !== finalName;
-            const eventName = finalName.toLowerCase().substring(2);
-            element.addEventListener(eventName, value as EventListenerOrEventListenerObject, useCapture);
-        } else if (name === "style" && typeof value !== "string") {
-            // Special handler for style with a value of type CSSStyleDeclaration
-            transferKnownProperties(value, element.style);
-        } else if (name === "dangerouslySetInnerHTML") element.innerHTML = value as string;
-        else if (value === true) element.setAttribute(name, name);
-        else if (value || value === 0 || value === "") element.setAttribute(name, value.toString());
+        if (!(element instanceof HTMLElement || element instanceof SVGElement)) continue;
+        setAttribute(element, name, attrs[name]);
     }
 }
diff --git a/src/types.ts b/src/types.ts
index e97e4996c228206e9abc419b731764579964cec3..7b575999d37745da3d359f7d83edbbea389ee17f 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -6,7 +6,11 @@ import type {
     SVGElementAttributes,
 } from "tsx-dom-types";
 
-export type ComponentChild = ComponentChild[] | JSX.Element | string | number | boolean | undefined | null;
+type RefAttr<T> = {
+  [K in keyof T]?: Ref<Extract<T[K], string | boolean | undefined>> | T[K];
+};
+
+export type ComponentChild = ComponentChild[] | JSX.Element | string | number | boolean | undefined | null | Ref<JSX.Element | string | number | boolean | undefined | null>;
 export type ComponentChildren = ComponentChild | ComponentChild[];
 export interface BaseProps {
     children?: ComponentChildren;
@@ -35,12 +39,12 @@ export type CustomElementProps<TBase, TName extends keyof HTMLElementTagNameMap
 export type SVGAndHTMLElementKeys = keyof SVGElementTagNameMap & keyof HTMLElementTagNameMap;
 export type SVGOnlyElementKeys = Exclude<keyof SVGElementTagNameMap, SVGAndHTMLElementKeys>;
 export type IntrinsicElementsHTML = {
-    [TKey in keyof HTMLElementTagNameMap]?: HTMLElementAttributes<TKey> &
+    [TKey in keyof HTMLElementTagNameMap]?: RefAttr<HTMLElementAttributes<TKey>> &
         HTMLComponentProps<HTMLElementTagNameMap[TKey]> &
         EventAttributes<HTMLElementTagNameMap[TKey]>;
 };
 export type IntrinsicElementsSVG = {
-    [TKey in SVGOnlyElementKeys]?: SVGElementAttributes<TKey> &
+    [TKey in SVGOnlyElementKeys]?: RefAttr<SVGElementAttributes<TKey>> &
         HTMLComponentProps<SVGElementTagNameMap[TKey]> &
         EventAttributes<SVGElementTagNameMap[TKey]>;
 };
diff --git a/src/utils.ts b/src/utils.ts
index 132f663afae342bf8be37e361269e95a2f18671c..d0a8ce5c116b07379963cf68139e6e8d5551fd37 100644
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,7 +1,34 @@
 import { ComponentAttributes, ComponentChild } from "./types";
 
-function applyChild(element: JSX.Element, child: ComponentChild) {
-    if (child instanceof Element) element.appendChild(child);
+function applyChild(element: JSX.Element, child: ComponentChild | Ref<ComponentChild>) {
+    if (child && typeof child === "object" && "onUpdate" in child && typeof child.onUpdate === "function") {
+        let el: Node | null = null;
+        const handler = () => {
+            const value = child.value;
+            if (value instanceof Node) {
+                el?.parentNode?.removeChild(el);
+                el = value;
+                element.appendChild(el);
+            } else if (typeof value === "string" || typeof value === "number") {
+                if (el instanceof Text) {
+                    el.textContent = value.toString();
+                } else {
+                    el?.parentNode?.removeChild(el);
+                    el = document.createTextNode(value.toString());
+                    element.appendChild(el);
+                }
+            } else {
+                console.warn("Unknown type to append: ", value);
+                el?.parentNode?.removeChild(el);
+                el = null;
+            }
+        };
+        child.onUpdate(handler);
+        handler();
+        return;
+    }
+    if (child instanceof Node) 
+        element.appendChild(child);
     else if (typeof child === "string" || typeof child === "number")
         element.appendChild(document.createTextNode(child.toString()));
     else console.warn("Unknown type to append: ", child);
diff --git a/tsconfig.build.json b/tsconfig.build.json
index b5c5bc08a4fefdeebcbd1f116ef53189d74f3f14..d6d480f3f6ebc7515112c400035a1c13079d5ca4 100644
--- a/tsconfig.build.json
+++ b/tsconfig.build.json
@@ -1,5 +1,7 @@
 {
   "extends": ".",
   "compilerOptions": { "paths": {} },
-  "files": ["src/index.ts"]
+  "include": [
+    "src/*.ts"
+  ]
 }
