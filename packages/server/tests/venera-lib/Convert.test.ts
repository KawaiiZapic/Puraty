import { Convert } from "@/venera-lib/Convert";
import assert from "../assert";

const test_string_str = "1A+å•ŠðŸŽ†";
const test_string = new TextEncoder().encode(test_string_str).buffer;

// All test under is relying on Hex encode, hex encode must be tested first
await assert.eq("Hex encode", () => {
  return Convert.hexEncode(test_string);
}, "31412be5958af09f8e86");

assert.eq("Base64 encode", () => {
  return Convert.encodeBase64(test_string);
}, "MUEr5ZWK8J+Ohg==");

assert.eq("Base64 decode", () => {
  return Convert.decodeUtf8(Convert.decodeBase64("MUEr5ZWK8J+Ohg=="));
}, test_string_str);

// All encrypted test data is generated by crypto-js
const encryptKey = Convert.md5(Convert.encodeUtf8("Su9erSecret!"));
// Random 128bit IV
const iv = Convert.decodeBase64("c1vK8myYIi/mNvpWhQVsiA==");
// Decrypt result is generated by Venera to ensure compatibility
const decryptResult = "31412be5958af09f8e86060606060606";

assert.eq("AES-CBC", () => {
  return Convert.hexEncode(
    Convert.decryptAesCbc(
      Convert.decodeBase64("gyPgVSzhNjAV1b16yO+BDw=="), 
      encryptKey,
      iv
    )
  );
}, decryptResult);

assert.eq("AES-ECB", () => {
  return Convert.hexEncode(
    Convert.decryptAesEcb(
      Convert.decodeBase64("9h5+xLLDvFfBSg8yop39rQ=="), 
      encryptKey
    )
  );
}, decryptResult);

type DigestType = "md5" | "sha1" | "sha256" | "sha512";

const digest_result: Record<DigestType, string> = {
  md5: "ba72ecd6b2dc94218de6f6c661ea513a",
  sha1: "a3c68b4f3b531db92a3c67727d0c54b6c8026084",
  sha256: "fba3349c8f44cbef82e90d0280683332025face3acc74950fb9e2af238abfa20",
  sha512: "b06542f5e64a721c245d6bb706748ba96c5b466d87eacd1f0790b9c88eae6b620b6e36cdb04e071106898ba7112f2c74a1b74a3bc914d7761d4472250f72d43a"
};

for (const type in digest_result) {
  assert.eq(`${type} digest`, () => {
    return Convert.hexEncode(Convert[type as DigestType](test_string));
  }, digest_result[type as DigestType])
}

const hmac_digest_result = {
  md5: "069da2543a677a857d3d5ef34eba363e",
  sha1: "0e08b7195f0ac42744492da4a48e57bb8a31f8ef",
  sha256: "48dbe506f35a4cce1dc4c6442f2e5fda28602c936f7197537ca5fbcbc33b5679",
  sha512: "f2d55c2a450d396a2864777eb514a606f8f9534fb8c3622d533c26a808a79cb23591730a8b1d0387ad57bab6181735a98318d36c3844b2209f9df10c95939b6a"
};

for (const type in digest_result) {
  assert.eq(`${type}-hmac digest`, () => {
    return Convert.hmacString(encryptKey, test_string, type as DigestType);
  }, hmac_digest_result[type as DigestType])
}
